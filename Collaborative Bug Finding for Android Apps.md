# Collaborative Bug Finding for Android Apps

## 文章思路

由于目前安卓应用的种类及其繁多，它又基本依靠于目前不可或缺的智能手机运行。因此移动应用程序的可靠性和可用性对于确保令人满意的用户体验至关重要。根据最近的一项调查，56%的受访者在使用移动应用程序时遇到过问题，79%的受访者如果一个应用程序未能达到他们的预期，就会重试一两次。因此，对移动应用程序的测试和分析技术的需求不断增加。因此对安卓应用的测试的需求也十分急切。本文就提出了一种新的bug查找的思路-协作式查找：通过三种程序员之间不同程度的交互，来做到使用其他类似应用程序中的漏洞来发现被测试应用程序中的漏洞的新方法。前两种情况的协作式查找对寻找潜在的bug有一定帮助，但同时也很耗时。因此提出第三种方式和相应工具Bugine，并对它的工作原理了相应分析，说明存在的缺陷。

## 安卓应用测试问题

目前的自动化测试软件问题尚不成熟，目前的提出的一些自动化技术和移动应用修复的技术基本都是针对更加严重的应用崩溃，或者是严重影响使用的bug。而对一些小的bug不太重视，这样的应用虽能使用，但是它的使用体验并不好。其次之前的研究缺少对测试工具的认识，导致测试不好进行，再者，据一些研究所说，应用程序开发者更喜欢阅读用自然语言编写的自动生成的测试。然而，现有的自动化测试技术只能生成在开发人员难以理解的低级事件。这样就导致了我们需求的自然语言自动化测试也很难完成，测试工作难以变得简易。对于像Mozilla和Eclipse这样的大型软件项目，有多达数千个用自然语言编写的错误报告。因此，以前关于重复错误报告检测的方法利用错误报告之间的相似性来进行错误本地化。事实上，许多类似的错误报告不仅存在于同一个项目中，而且也存在于不同的软件项目中，特别是对于安卓应用程序。这样的情况非常多见，因此引入的协作式漏洞查找能够在本应用查找bug后，也对别的具有同组件的应用进行测试，以查找bug。

## 协作式漏洞发现

分为三种，分别是coder-vs-coder setting、coder-vs-manual-issues settings、coder-vs-auto-issues settings，他们在漏洞查找上各有不同，循序渐进。

## coder-vs-coder setting

这种形式的协作漏洞查找发生在协作编程当中，我们假设驾驶员和导航员都是属于同一组织的程序员，但他们每个人都可能开发一个不同的应用程序，协作的bug查找过程从一个程序员A（驾驶员）在团队讨论页面中发布一个针对AppA的GitHub问题i开始。在问题发出之后，同一组织中的另一个程序员（导航员）可以阅读GitHub的问题，并思考我是否适用于应用程序AppB。这一步要求导航员创造性地思考AppA和AppB之间是否存在一些相似性，从而允许在AppB重复使用（假设导航员来定义自己的相似性概念）。如果导航员在问题i中成功地复制了这个问题，那么他将把新的问题j发布到团队讨论中。我们称之为一对共享，i是最初共享的问题，j是派生的问题。当组织的另一个成员发布不同于i和j的新GitHub问题时，该过程重复。在这种情况下，一个问题的共享对数越多，发现一般bug的可能性就越大。在这样的情况下就能在许多相关甚至关联不大的应用之间建立起联系，在测试一个应用时也能够同时为这些关联应用进行一定的测试。

## coder-vs-manual-issues setting

在coder-vs-coder setting当中，如果需要进行bug查找的话，就需要有一位程序员先行发出一个bug报告，这样会导致很多程序员被动地等待这个报告，并且就算有了bug报告也有可能无法复用，这导致协作bug发现的效率很低。因此引入了coder-vs-manual-issues setting的模式。在这种情况下，驾驶员是一个希望执行协作错误查找，但不属于任何组织的程序员，而导航程序则带有GitHub问题列表，这样的话可能帮助程序员想要找到自己所写的软件的bug。假设程序员A想要找到可能影响他开发的应用程序AppA的错误。这个过程首先随机选择两个应用：一个与AppA属于相同类别的AppB和一个与AppA属于不同类别的AppC。选择相同类别应用程序可以让A找到执行类似任务的应用程序中可能出现的特定bug，而选择不同类别应用程序让A可以找到所有安卓应用程序中可能出现的一般bug。在选择应用程序后，A分别从AppB和AppC中选择一些GitHub问题。然后，A将考虑是否可以在AppB/APPC中复制AppA中的测试场景，从而揭露出可能存在的bug。而这同样是需要一些创新性思维的。

## coder-vs-auto-issues settings

在测试中我们根据反馈发现，应用程序中确实存在许多相似甚至相同的功能，看到别的应用的bug报告也会去思考自己应用可能存在的bug，但是这样的协作bug查找效率不是很高，需要花费更多的时间在查看不同的应用程序以及关注他们产生的问题上。如果不使用这样的编程，那么我们只需要关注自己应用的bug，但如果使用了协作式，就需要花费一些时间在别的应用上，这样可能会导致效率不高，尽管这样更有可能找到bug。为了解决这样的问题，提出了coder-vs-auto-issues settings。这个协作bug查找能够自动为被测试应用选择相关GitHub问题的方法，这样开发人员可以专注于创新性思考测试场景。这里提出了一个新的工具Bugine，它能够有效地实现这种协作bug查找。

## Bugine

Bugine构建了一个从开源的安卓应用程序中获得的GitHub问题的数据库，并对这些问题进行预处理，以提取它们的元数据。对于数据库中的每个应用程序，提取其应用程序描述文件，用于将来的比较。给定一个正在测试的应用程序，Bugine提取其UI组件以获取其应用程序描述文件。然后使用待测App的应用描述文件与数据库中所有应用的应用描述文件之间的相似性来搜索与待测App相似的应用。这种相似性作为排名函数的输入，该函数对数据库中的GitHub问题进行了优先排序。最后，Bugine输出一个针对App查询的相关GitHub问题的排名列表。Bugine的具体工作原理如下。

首先，建立一个关于GitHub问题的数据库。为了建立数据库，首先通过爬虫在GitHub获得了一组开源的安卓应用程序。爬虫根据（1）GitHub的星星数量，（2）评论数量和谷歌Play的下载数量，（3）GitHub问题的数量和（4）类别进行选择。对于每个选定的应用程序，提取其所有问题，并收集每个问题的元数据(例如，标题、作者、用户评论数量、标签、问题状态、主体等），这样就获得了不同应用的不同问题。

进行数据预处理，由于数据库中的所有的GitHub问题都是用自然语言编写的，需要使用自然语言处理(NLP)技术进行预处理，然后将它们存储到数据库中。同时还需要还对所有的XML文件执行类似的预处理。具体执行以下步骤：令牌化：将每个问题转换为单词列表（令牌）。停止词删除：停止词是没有完全词汇意义的词(如łthez、łisz、łthatz)。使用PythonNLTK库来删除停止词。约定统一：考虑到不同的Android UI组件的命名约定，Bugine使用了Humps，这是一个能够在蛇形命名法，驼峰命名法和帕斯卡命名法之间转换的Python库，用来统一变量命名中不同的命名约定。并且通过词调和词理化模板减少了变化词的基本信息并将其组合在一起，从而能够进行分析。之后便可将语料库转化为令牌流，方便后续使用。

提取应用程序描述文件。在此步骤中，Bugine将标识并解析文件夹src/main/res中的所有XML文件，以生成应用程序描述文件。同时丢弃了对应用程序不必需的元素样式（例如颜色和字体），只保留描述应用程序行为的重要属性。对于每一对应用程序(AppA，AppB)，会比较和匹配它们的应用程序描述文件。这个描述文件用于（对应用程序的类别进行分类(假设如果AppA和AppB中的UI组件集相似，那么AppA和AppB属于相同的类别)，以及生成候选搜索关键字以识别相关的GitHub问题。然后，Bugine通过总结这两个应用描述文件中的常见部分，将这些应用描述转换为查询短语。同时采用重叠系数计算文本相似度，他的公式为|X∩Y|/min（|X|，|Y|）重叠系数范围在零到一之间，它相比于jaccard相似度来说对数据集的大小更加敏感。之后使用n-grams来衡量Github问题和测试体之间的相似度。最后通过不同的权重来对语料库中的不同语句重要性判断，最后得出语料库的相似度。

最后对相应的Github问题进行排序。此步骤的目标是为应用查询生成一个相关GitHub问题的排名列表。在前面的步骤中，获得了针对问题App的类似应用程序。我们使用从应用程序描述文件中提取的每个查询短语来搜索相关问题，并根据其重要性、相关性和再现性对结果进行排序。决定GitHub问题i质量的一个关键因素是i中对测试场景的描述效果如何。一项实证研究表明，开发人员认为的一个良好的错误报告能够包括复制、观察和预期行为以及堆栈跟踪的步骤。研究表明，一份详细的漏洞报告可以帮助开发人员缩小漏洞的搜索空间，并节省修复漏洞的时间。具体的排序的思路如下：问题长度衡量了问题的详细程度（假设较长的问题包含更多的信息），而问题状态描述了它的重要性（假设封闭的问题更重要）。参考提交SHA度量将检查问题中提到的问题是否已得到解决（如存在提交SHA所证明）。同时问题回答数量，即有大量回答的问题也很重要。它同时使用Hit_all和Hit_overlap来查找字符串的相似性，因为如果所有的搜索关键字都出现在语料库(Hit_all)中，那么应该给文本额外的权重。Hit_hot_words因子表示当它的bug报告更加优秀时，应该给与更高的优先级，至此我们能够得到这些问题的排名分数。

实验中使用了两个方法来检测Bugine的性能。一是Pree@k,他测量了排名列表中前k个文档的检索精度。二是MRR（Mean Reciprocal Rank），对于每个问题，它定位排序列表中第一个相关文档的位置。MRR越高，排序表现越佳。最后证明了，Bugine能够有效地找出更多的bug，是能够很好运作的。但它的一些缺陷也暴露了出来。Bugine固然能够自动查找到相关的bug，但是不同的测试方法会影响到发现bug的时间和生成测试的覆盖范围，并且如果使用面受到限制的话，它的效果可能也不太好，所以实验中甚至使用了奖励机制来鼓励学生使用Bugine,并且没有限制寻找漏洞的测试方法，最后，在对bug结果进行人工检查分类时，也可能对结果产生一定影响。

## 总结

协作式漏洞查找技术是一个比较新的观念，它的提出为软件测试提供了一些新的方向和新的启发。1.虽然它是基于安卓应用，但它也可推广到整所有具有共同特征的程序，实现重用来自不同应用程序的错误报告，从而拓宽软件测试的途径。2.他能够为新的测试生成方法提供帮助。由于bug报告是用自然语言编写的，这个方法可能有助于减轻开发人员在学习新的机器人测试框架或api时的负担。3.实现全自动的协作测试。自动协作bug发现包括：测试传输，这需要将原始问题中的所有相关UI组件映射到派生问题(可以使用Bugine中的应用程序描述文件)，以及将自然语言将报告翻译为可重复的测试脚本。这样可以有助于实现自动化的协作测试，提高测试效率。





